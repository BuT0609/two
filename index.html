<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>九大行星粒子全息系统</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Arial', sans-serif; }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; pointer-events: none; }
    </style>
</head>
<body>
    <div id="loading">系统初始化中...</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "gsap": "https://unpkg.com/gsap@3.12.5/index.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
        import gsap from 'gsap';

        // --- 配置区 ---
        const PARTICLE_COUNT = 30000; // 粒子总数，显卡好可以改大
        const PLANET_CONFIG = {
            '水星 (Mercury)': { radius: 30, colors: ['#A5A5A5', '#E5E5E5', '#5A5A5A'] },
            '金星 (Venus)': { radius: 50, colors: ['#E6DBAC', '#D6A659', '#F2E8C4'] },
            '地球 (Earth)': { radius: 52, colors: ['#2244AA', '#11AA44', '#FFFFFF', '#001133'] },
            '火星 (Mars)': { radius: 40, colors: ['#E27B58', '#C1440E', '#691F09'] },
            '木星 (Jupiter)': { radius: 90, colors: ['#C88B3A', '#F2DBA9', '#7C5230'] },
            '土星 (Saturn)': { radius: 80, colors: ['#EAD6B8', '#AFA184', '#CEB8B8'], hasRing: true },
            '天王星 (Uranus)': { radius: 60, colors: ['#93B8BE', '#D1F0F5', '#4B70DD'] },
            '海王星 (Neptune)': { radius: 58, colors: ['#295493', '#3E54E8', '#182C5C'] },
            '冥王星 (Pluto)': { radius: 25, colors: ['#E0C7A6', '#4D3B33', '#111111'] } // 致敬经典
        };

        // --- 初始化场景 ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.002);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 20, 200);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;

        // --- 创建粒子系统 ---
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const colors = new Float32Array(PARTICLE_COUNT * 3);
        const sizes = new Float32Array(PARTICLE_COUNT);
        
        // 存储粒子的目标状态，用于动画
        const targetColors = new Float32Array(PARTICLE_COUNT * 3);
        const originalPositions = new Float32Array(PARTICLE_COUNT * 3); // 备份位置

        const colorObj = new THREE.Color();

        // 初始化粒子位置（默认球体）
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
            const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
            
            // 初始半径设为地球大小
            const r = 52 + (Math.random() - 0.5) * 2; 

            const x = r * Math.cos(theta) * Math.sin(phi);
            const y = r * Math.sin(theta) * Math.sin(phi);
            const z = r * Math.cos(phi);

            positions[i * 3] = x;
            positions[i * 3 + 1] = y;
            positions[i * 3 + 2] = z;

            originalPositions[i * 3] = x;
            originalPositions[i * 3 + 1] = y;
            originalPositions[i * 3 + 2] = z;

            // 初始颜色
            colors[i * 3] = 0;
            colors[i * 3 + 1] = 0;
            colors[i * 3 + 2] = 0;

            sizes[i] = Math.random();
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

        // 粒子材质（使用ShaderMaterial模拟辉光点）
        const material = new THREE.PointsMaterial({
            size: 0.8,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true,
            opacity: 0.8
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- 核心功能：切换星球 ---
        const params = {
            planet: '地球 (Earth)'
        };

        function changePlanet(planetName) {
            const config = PLANET_CONFIG[planetName];
            const palette = config.colors;
            const radius = config.radius;
            const hasRing = config.hasRing || false;

            // 1. 重新计算每个粒子的目标颜色和位置
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                
                // 颜色采样：从预设色板中随机取色
                const hexColor = palette[Math.floor(Math.random() * palette.length)];
                colorObj.set(hexColor);
                
                // 使用 GSAP 动画过渡颜色
                gsap.to(colors, {
                    [i * 3]: colorObj.r,
                    [i * 3 + 1]: colorObj.g,
                    [i * 3 + 2]: colorObj.b,
                    duration: 1.5 + Math.random(), // 随机延迟，显得自然
                    onUpdate: () => {
                        geometry.attributes.color.needsUpdate = true;
                    }
                });

                // 位置调整（呼吸缩放）
                // 我们基于原始的单位球坐标，乘以新的半径
                // 如果是土星，我们将20%的粒子移动到光环轨道
                let targetX, targetY, targetZ;
                const isRingParticle = hasRing && i > PARTICLE_COUNT * 0.8;

                if (isRingParticle) {
                    // 土星环逻辑
                    const angle = Math.random() * Math.PI * 2;
                    const ringRadius = radius * (1.5 + Math.random() * 0.8); // 环半径
                    targetX = Math.cos(angle) * ringRadius;
                    targetY = (Math.random() - 0.5) * 2; // 极扁的Y轴
                    targetZ = Math.sin(angle) * ringRadius;
                } else {
                    // 球体逻辑
                    // 归一化原始位置
                    const ox = originalPositions[i * 3];
                    const oy = originalPositions[i * 3 + 1];
                    const oz = originalPositions[i * 3 + 2];
                    const originalR = Math.sqrt(ox*ox + oy*oy + oz*oz);
                    
                    targetX = (ox / originalR) * radius;
                    targetY = (oy / originalR) * radius;
                    targetZ = (oz / originalR) * radius;
                }

                // 动画位移
                gsap.to(positions, {
                    [i * 3]: targetX,
                    [i * 3 + 1]: targetY,
                    [i * 3 + 2]: targetZ,
                    duration: 2,
                    ease: "power2.inOut",
                    onUpdate: () => {
                        geometry.attributes.position.needsUpdate = true;
                    }
                });
            }
        }

        // --- 交互界面 ---
        const gui = new GUI({ title: '控制台' });
        gui.add(params, 'planet', Object.keys(PLANET_CONFIG)).name('选择行星').onChange(changePlanet);
        gui.add(material, 'size', 0.1, 3).name('粒子大小');
        gui.add(controls, 'autoRotate').name('自动旋转');

        // 初始化
        document.getElementById('loading').style.display = 'none';
        changePlanet('地球 (Earth)');

        // --- 动画循环 ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            // 给粒子添加微小的波浪浮动效果，增加灵动感
            // 注意：大规模循环会消耗CPU，这里只演示简单旋转
            particles.rotation.y = time * 0.05;

            controls.update();
            renderer.render(scene, camera);
        }

        animate();

        // 窗口自适应
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
